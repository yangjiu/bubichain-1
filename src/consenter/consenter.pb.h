// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: consenter.proto

#ifndef PROTOBUF_consenter_2eproto__INCLUDED
#define PROTOBUF_consenter_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protocol {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_consenter_2eproto();
void protobuf_AssignDesc_consenter_2eproto();
void protobuf_ShutdownFile_consenter_2eproto();

class LedgerHeaderLite;
class TransactionLite;
class TransactionLiteSet;

// ===================================================================

class TransactionLite : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.TransactionLite) */ {
 public:
  TransactionLite();
  virtual ~TransactionLite();

  TransactionLite(const TransactionLite& from);

  inline TransactionLite& operator=(const TransactionLite& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransactionLite& default_instance();

  void Swap(TransactionLite* other);

  // implements Message ----------------------------------------------

  inline TransactionLite* New() const { return New(NULL); }

  TransactionLite* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransactionLite& from);
  void MergeFrom(const TransactionLite& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TransactionLite* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string topic = 1;
  bool has_topic() const;
  void clear_topic();
  static const int kTopicFieldNumber = 1;
  const ::std::string& topic() const;
  void set_topic(const ::std::string& value);
  void set_topic(const char* value);
  void set_topic(const char* value, size_t size);
  ::std::string* mutable_topic();
  ::std::string* release_topic();
  void set_allocated_topic(::std::string* topic);

  // required int64 sequence = 2;
  bool has_sequence() const;
  void clear_sequence();
  static const int kSequenceFieldNumber = 2;
  ::google::protobuf::int64 sequence() const;
  void set_sequence(::google::protobuf::int64 value);

  // required string operation = 3;
  bool has_operation() const;
  void clear_operation();
  static const int kOperationFieldNumber = 3;
  const ::std::string& operation() const;
  void set_operation(const ::std::string& value);
  void set_operation(const char* value);
  void set_operation(const char* value, size_t size);
  ::std::string* mutable_operation();
  ::std::string* release_operation();
  void set_allocated_operation(::std::string* operation);

  // @@protoc_insertion_point(class_scope:protocol.TransactionLite)
 private:
  inline void set_has_topic();
  inline void clear_has_topic();
  inline void set_has_sequence();
  inline void clear_has_sequence();
  inline void set_has_operation();
  inline void clear_has_operation();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr topic_;
  ::google::protobuf::int64 sequence_;
  ::google::protobuf::internal::ArenaStringPtr operation_;
  friend void  protobuf_AddDesc_consenter_2eproto();
  friend void protobuf_AssignDesc_consenter_2eproto();
  friend void protobuf_ShutdownFile_consenter_2eproto();

  void InitAsDefaultInstance();
  static TransactionLite* default_instance_;
};
// -------------------------------------------------------------------

class TransactionLiteSet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.TransactionLiteSet) */ {
 public:
  TransactionLiteSet();
  virtual ~TransactionLiteSet();

  TransactionLiteSet(const TransactionLiteSet& from);

  inline TransactionLiteSet& operator=(const TransactionLiteSet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransactionLiteSet& default_instance();

  void Swap(TransactionLiteSet* other);

  // implements Message ----------------------------------------------

  inline TransactionLiteSet* New() const { return New(NULL); }

  TransactionLiteSet* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransactionLiteSet& from);
  void MergeFrom(const TransactionLiteSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TransactionLiteSet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes preledger_hash = 1;
  bool has_preledger_hash() const;
  void clear_preledger_hash();
  static const int kPreledgerHashFieldNumber = 1;
  const ::std::string& preledger_hash() const;
  void set_preledger_hash(const ::std::string& value);
  void set_preledger_hash(const char* value);
  void set_preledger_hash(const void* value, size_t size);
  ::std::string* mutable_preledger_hash();
  ::std::string* release_preledger_hash();
  void set_allocated_preledger_hash(::std::string* preledger_hash);

  // repeated .protocol.TransactionLite txs = 2;
  int txs_size() const;
  void clear_txs();
  static const int kTxsFieldNumber = 2;
  const ::protocol::TransactionLite& txs(int index) const;
  ::protocol::TransactionLite* mutable_txs(int index);
  ::protocol::TransactionLite* add_txs();
  ::google::protobuf::RepeatedPtrField< ::protocol::TransactionLite >*
      mutable_txs();
  const ::google::protobuf::RepeatedPtrField< ::protocol::TransactionLite >&
      txs() const;

  // @@protoc_insertion_point(class_scope:protocol.TransactionLiteSet)
 private:
  inline void set_has_preledger_hash();
  inline void clear_has_preledger_hash();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr preledger_hash_;
  ::google::protobuf::RepeatedPtrField< ::protocol::TransactionLite > txs_;
  friend void  protobuf_AddDesc_consenter_2eproto();
  friend void protobuf_AssignDesc_consenter_2eproto();
  friend void protobuf_ShutdownFile_consenter_2eproto();

  void InitAsDefaultInstance();
  static TransactionLiteSet* default_instance_;
};
// -------------------------------------------------------------------

class LedgerHeaderLite : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.LedgerHeaderLite) */ {
 public:
  LedgerHeaderLite();
  virtual ~LedgerHeaderLite();

  LedgerHeaderLite(const LedgerHeaderLite& from);

  inline LedgerHeaderLite& operator=(const LedgerHeaderLite& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LedgerHeaderLite& default_instance();

  void Swap(LedgerHeaderLite* other);

  // implements Message ----------------------------------------------

  inline LedgerHeaderLite* New() const { return New(NULL); }

  LedgerHeaderLite* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LedgerHeaderLite& from);
  void MergeFrom(const LedgerHeaderLite& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LedgerHeaderLite* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 sequence = 1;
  bool has_sequence() const;
  void clear_sequence();
  static const int kSequenceFieldNumber = 1;
  ::google::protobuf::int64 sequence() const;
  void set_sequence(::google::protobuf::int64 value);

  // required bytes hash = 2;
  bool has_hash() const;
  void clear_hash();
  static const int kHashFieldNumber = 2;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // required bytes phash = 3;
  bool has_phash() const;
  void clear_phash();
  static const int kPhashFieldNumber = 3;
  const ::std::string& phash() const;
  void set_phash(const ::std::string& value);
  void set_phash(const char* value);
  void set_phash(const void* value, size_t size);
  ::std::string* mutable_phash();
  ::std::string* release_phash();
  void set_allocated_phash(::std::string* phash);

  // required bytes txs_hash = 4;
  bool has_txs_hash() const;
  void clear_txs_hash();
  static const int kTxsHashFieldNumber = 4;
  const ::std::string& txs_hash() const;
  void set_txs_hash(const ::std::string& value);
  void set_txs_hash(const char* value);
  void set_txs_hash(const void* value, size_t size);
  ::std::string* mutable_txs_hash();
  ::std::string* release_txs_hash();
  void set_allocated_txs_hash(::std::string* txs_hash);

  // required int64 apply_time = 5;
  bool has_apply_time() const;
  void clear_apply_time();
  static const int kApplyTimeFieldNumber = 5;
  ::google::protobuf::int64 apply_time() const;
  void set_apply_time(::google::protobuf::int64 value);

  // required int64 tx_count = 6;
  bool has_tx_count() const;
  void clear_tx_count();
  static const int kTxCountFieldNumber = 6;
  ::google::protobuf::int64 tx_count() const;
  void set_tx_count(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.LedgerHeaderLite)
 private:
  inline void set_has_sequence();
  inline void clear_has_sequence();
  inline void set_has_hash();
  inline void clear_has_hash();
  inline void set_has_phash();
  inline void clear_has_phash();
  inline void set_has_txs_hash();
  inline void clear_has_txs_hash();
  inline void set_has_apply_time();
  inline void clear_has_apply_time();
  inline void set_has_tx_count();
  inline void clear_has_tx_count();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 sequence_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::internal::ArenaStringPtr phash_;
  ::google::protobuf::internal::ArenaStringPtr txs_hash_;
  ::google::protobuf::int64 apply_time_;
  ::google::protobuf::int64 tx_count_;
  friend void  protobuf_AddDesc_consenter_2eproto();
  friend void protobuf_AssignDesc_consenter_2eproto();
  friend void protobuf_ShutdownFile_consenter_2eproto();

  void InitAsDefaultInstance();
  static LedgerHeaderLite* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// TransactionLite

// required string topic = 1;
inline bool TransactionLite::has_topic() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransactionLite::set_has_topic() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransactionLite::clear_has_topic() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransactionLite::clear_topic() {
  topic_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic();
}
inline const ::std::string& TransactionLite::topic() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionLite.topic)
  return topic_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransactionLite::set_topic(const ::std::string& value) {
  set_has_topic();
  topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.TransactionLite.topic)
}
inline void TransactionLite::set_topic(const char* value) {
  set_has_topic();
  topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.TransactionLite.topic)
}
inline void TransactionLite::set_topic(const char* value, size_t size) {
  set_has_topic();
  topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.TransactionLite.topic)
}
inline ::std::string* TransactionLite::mutable_topic() {
  set_has_topic();
  // @@protoc_insertion_point(field_mutable:protocol.TransactionLite.topic)
  return topic_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransactionLite::release_topic() {
  // @@protoc_insertion_point(field_release:protocol.TransactionLite.topic)
  clear_has_topic();
  return topic_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransactionLite::set_allocated_topic(::std::string* topic) {
  if (topic != NULL) {
    set_has_topic();
  } else {
    clear_has_topic();
  }
  topic_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic);
  // @@protoc_insertion_point(field_set_allocated:protocol.TransactionLite.topic)
}

// required int64 sequence = 2;
inline bool TransactionLite::has_sequence() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransactionLite::set_has_sequence() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransactionLite::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransactionLite::clear_sequence() {
  sequence_ = GOOGLE_LONGLONG(0);
  clear_has_sequence();
}
inline ::google::protobuf::int64 TransactionLite::sequence() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionLite.sequence)
  return sequence_;
}
inline void TransactionLite::set_sequence(::google::protobuf::int64 value) {
  set_has_sequence();
  sequence_ = value;
  // @@protoc_insertion_point(field_set:protocol.TransactionLite.sequence)
}

// required string operation = 3;
inline bool TransactionLite::has_operation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransactionLite::set_has_operation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransactionLite::clear_has_operation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransactionLite::clear_operation() {
  operation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_operation();
}
inline const ::std::string& TransactionLite::operation() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionLite.operation)
  return operation_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransactionLite::set_operation(const ::std::string& value) {
  set_has_operation();
  operation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.TransactionLite.operation)
}
inline void TransactionLite::set_operation(const char* value) {
  set_has_operation();
  operation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.TransactionLite.operation)
}
inline void TransactionLite::set_operation(const char* value, size_t size) {
  set_has_operation();
  operation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.TransactionLite.operation)
}
inline ::std::string* TransactionLite::mutable_operation() {
  set_has_operation();
  // @@protoc_insertion_point(field_mutable:protocol.TransactionLite.operation)
  return operation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransactionLite::release_operation() {
  // @@protoc_insertion_point(field_release:protocol.TransactionLite.operation)
  clear_has_operation();
  return operation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransactionLite::set_allocated_operation(::std::string* operation) {
  if (operation != NULL) {
    set_has_operation();
  } else {
    clear_has_operation();
  }
  operation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), operation);
  // @@protoc_insertion_point(field_set_allocated:protocol.TransactionLite.operation)
}

// -------------------------------------------------------------------

// TransactionLiteSet

// required bytes preledger_hash = 1;
inline bool TransactionLiteSet::has_preledger_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransactionLiteSet::set_has_preledger_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransactionLiteSet::clear_has_preledger_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransactionLiteSet::clear_preledger_hash() {
  preledger_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_preledger_hash();
}
inline const ::std::string& TransactionLiteSet::preledger_hash() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionLiteSet.preledger_hash)
  return preledger_hash_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransactionLiteSet::set_preledger_hash(const ::std::string& value) {
  set_has_preledger_hash();
  preledger_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.TransactionLiteSet.preledger_hash)
}
inline void TransactionLiteSet::set_preledger_hash(const char* value) {
  set_has_preledger_hash();
  preledger_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.TransactionLiteSet.preledger_hash)
}
inline void TransactionLiteSet::set_preledger_hash(const void* value, size_t size) {
  set_has_preledger_hash();
  preledger_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.TransactionLiteSet.preledger_hash)
}
inline ::std::string* TransactionLiteSet::mutable_preledger_hash() {
  set_has_preledger_hash();
  // @@protoc_insertion_point(field_mutable:protocol.TransactionLiteSet.preledger_hash)
  return preledger_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransactionLiteSet::release_preledger_hash() {
  // @@protoc_insertion_point(field_release:protocol.TransactionLiteSet.preledger_hash)
  clear_has_preledger_hash();
  return preledger_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransactionLiteSet::set_allocated_preledger_hash(::std::string* preledger_hash) {
  if (preledger_hash != NULL) {
    set_has_preledger_hash();
  } else {
    clear_has_preledger_hash();
  }
  preledger_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), preledger_hash);
  // @@protoc_insertion_point(field_set_allocated:protocol.TransactionLiteSet.preledger_hash)
}

// repeated .protocol.TransactionLite txs = 2;
inline int TransactionLiteSet::txs_size() const {
  return txs_.size();
}
inline void TransactionLiteSet::clear_txs() {
  txs_.Clear();
}
inline const ::protocol::TransactionLite& TransactionLiteSet::txs(int index) const {
  // @@protoc_insertion_point(field_get:protocol.TransactionLiteSet.txs)
  return txs_.Get(index);
}
inline ::protocol::TransactionLite* TransactionLiteSet::mutable_txs(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.TransactionLiteSet.txs)
  return txs_.Mutable(index);
}
inline ::protocol::TransactionLite* TransactionLiteSet::add_txs() {
  // @@protoc_insertion_point(field_add:protocol.TransactionLiteSet.txs)
  return txs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::TransactionLite >*
TransactionLiteSet::mutable_txs() {
  // @@protoc_insertion_point(field_mutable_list:protocol.TransactionLiteSet.txs)
  return &txs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::TransactionLite >&
TransactionLiteSet::txs() const {
  // @@protoc_insertion_point(field_list:protocol.TransactionLiteSet.txs)
  return txs_;
}

// -------------------------------------------------------------------

// LedgerHeaderLite

// required int64 sequence = 1;
inline bool LedgerHeaderLite::has_sequence() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LedgerHeaderLite::set_has_sequence() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LedgerHeaderLite::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LedgerHeaderLite::clear_sequence() {
  sequence_ = GOOGLE_LONGLONG(0);
  clear_has_sequence();
}
inline ::google::protobuf::int64 LedgerHeaderLite::sequence() const {
  // @@protoc_insertion_point(field_get:protocol.LedgerHeaderLite.sequence)
  return sequence_;
}
inline void LedgerHeaderLite::set_sequence(::google::protobuf::int64 value) {
  set_has_sequence();
  sequence_ = value;
  // @@protoc_insertion_point(field_set:protocol.LedgerHeaderLite.sequence)
}

// required bytes hash = 2;
inline bool LedgerHeaderLite::has_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LedgerHeaderLite::set_has_hash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LedgerHeaderLite::clear_has_hash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LedgerHeaderLite::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hash();
}
inline const ::std::string& LedgerHeaderLite::hash() const {
  // @@protoc_insertion_point(field_get:protocol.LedgerHeaderLite.hash)
  return hash_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LedgerHeaderLite::set_hash(const ::std::string& value) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.LedgerHeaderLite.hash)
}
inline void LedgerHeaderLite::set_hash(const char* value) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.LedgerHeaderLite.hash)
}
inline void LedgerHeaderLite::set_hash(const void* value, size_t size) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.LedgerHeaderLite.hash)
}
inline ::std::string* LedgerHeaderLite::mutable_hash() {
  set_has_hash();
  // @@protoc_insertion_point(field_mutable:protocol.LedgerHeaderLite.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LedgerHeaderLite::release_hash() {
  // @@protoc_insertion_point(field_release:protocol.LedgerHeaderLite.hash)
  clear_has_hash();
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LedgerHeaderLite::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    set_has_hash();
  } else {
    clear_has_hash();
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:protocol.LedgerHeaderLite.hash)
}

// required bytes phash = 3;
inline bool LedgerHeaderLite::has_phash() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LedgerHeaderLite::set_has_phash() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LedgerHeaderLite::clear_has_phash() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LedgerHeaderLite::clear_phash() {
  phash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_phash();
}
inline const ::std::string& LedgerHeaderLite::phash() const {
  // @@protoc_insertion_point(field_get:protocol.LedgerHeaderLite.phash)
  return phash_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LedgerHeaderLite::set_phash(const ::std::string& value) {
  set_has_phash();
  phash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.LedgerHeaderLite.phash)
}
inline void LedgerHeaderLite::set_phash(const char* value) {
  set_has_phash();
  phash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.LedgerHeaderLite.phash)
}
inline void LedgerHeaderLite::set_phash(const void* value, size_t size) {
  set_has_phash();
  phash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.LedgerHeaderLite.phash)
}
inline ::std::string* LedgerHeaderLite::mutable_phash() {
  set_has_phash();
  // @@protoc_insertion_point(field_mutable:protocol.LedgerHeaderLite.phash)
  return phash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LedgerHeaderLite::release_phash() {
  // @@protoc_insertion_point(field_release:protocol.LedgerHeaderLite.phash)
  clear_has_phash();
  return phash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LedgerHeaderLite::set_allocated_phash(::std::string* phash) {
  if (phash != NULL) {
    set_has_phash();
  } else {
    clear_has_phash();
  }
  phash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), phash);
  // @@protoc_insertion_point(field_set_allocated:protocol.LedgerHeaderLite.phash)
}

// required bytes txs_hash = 4;
inline bool LedgerHeaderLite::has_txs_hash() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LedgerHeaderLite::set_has_txs_hash() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LedgerHeaderLite::clear_has_txs_hash() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LedgerHeaderLite::clear_txs_hash() {
  txs_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_txs_hash();
}
inline const ::std::string& LedgerHeaderLite::txs_hash() const {
  // @@protoc_insertion_point(field_get:protocol.LedgerHeaderLite.txs_hash)
  return txs_hash_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LedgerHeaderLite::set_txs_hash(const ::std::string& value) {
  set_has_txs_hash();
  txs_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.LedgerHeaderLite.txs_hash)
}
inline void LedgerHeaderLite::set_txs_hash(const char* value) {
  set_has_txs_hash();
  txs_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.LedgerHeaderLite.txs_hash)
}
inline void LedgerHeaderLite::set_txs_hash(const void* value, size_t size) {
  set_has_txs_hash();
  txs_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.LedgerHeaderLite.txs_hash)
}
inline ::std::string* LedgerHeaderLite::mutable_txs_hash() {
  set_has_txs_hash();
  // @@protoc_insertion_point(field_mutable:protocol.LedgerHeaderLite.txs_hash)
  return txs_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LedgerHeaderLite::release_txs_hash() {
  // @@protoc_insertion_point(field_release:protocol.LedgerHeaderLite.txs_hash)
  clear_has_txs_hash();
  return txs_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LedgerHeaderLite::set_allocated_txs_hash(::std::string* txs_hash) {
  if (txs_hash != NULL) {
    set_has_txs_hash();
  } else {
    clear_has_txs_hash();
  }
  txs_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), txs_hash);
  // @@protoc_insertion_point(field_set_allocated:protocol.LedgerHeaderLite.txs_hash)
}

// required int64 apply_time = 5;
inline bool LedgerHeaderLite::has_apply_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LedgerHeaderLite::set_has_apply_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LedgerHeaderLite::clear_has_apply_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LedgerHeaderLite::clear_apply_time() {
  apply_time_ = GOOGLE_LONGLONG(0);
  clear_has_apply_time();
}
inline ::google::protobuf::int64 LedgerHeaderLite::apply_time() const {
  // @@protoc_insertion_point(field_get:protocol.LedgerHeaderLite.apply_time)
  return apply_time_;
}
inline void LedgerHeaderLite::set_apply_time(::google::protobuf::int64 value) {
  set_has_apply_time();
  apply_time_ = value;
  // @@protoc_insertion_point(field_set:protocol.LedgerHeaderLite.apply_time)
}

// required int64 tx_count = 6;
inline bool LedgerHeaderLite::has_tx_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LedgerHeaderLite::set_has_tx_count() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LedgerHeaderLite::clear_has_tx_count() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LedgerHeaderLite::clear_tx_count() {
  tx_count_ = GOOGLE_LONGLONG(0);
  clear_has_tx_count();
}
inline ::google::protobuf::int64 LedgerHeaderLite::tx_count() const {
  // @@protoc_insertion_point(field_get:protocol.LedgerHeaderLite.tx_count)
  return tx_count_;
}
inline void LedgerHeaderLite::set_tx_count(::google::protobuf::int64 value) {
  set_has_tx_count();
  tx_count_ = value;
  // @@protoc_insertion_point(field_set:protocol.LedgerHeaderLite.tx_count)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_consenter_2eproto__INCLUDED
